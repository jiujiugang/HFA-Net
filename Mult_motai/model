import torch
from torch import nn
import torch.nn.functional as F
from modules.transformer import TransformerEncoder


class MULTModel(nn.Module):
    def __init__(self, hyp_params):
        super(MULTModel, self).__init__()
        self.orig_d_l, self.orig_d_v = hyp_params.orig_d_l, hyp_params.orig_d_v
        self.d_l = self.d_v = hyp_params.hidden_dim

        self.vonly = True
        self.aonly = False
        self.lonly = True

        self.num_heads = hyp_params.num_heads
        self.layers = hyp_params.layers
        self.attn_dropout = hyp_params.attn_dropout
        self.relu_dropout = hyp_params.relu_dropout
        self.res_dropout = hyp_params.res_dropout
        self.out_dropout = hyp_params.out_dropout
        self.embed_dropout = hyp_params.embed_dropout
        self.attn_mask = hyp_params.attn_mask

        combined_dim = 2 * (self.d_l + self.d_v)
        output_dim = hyp_params.output_dim

        # 1. Patch 序列通过 1D Conv 降维
        self.proj_l = nn.Conv1d(self.orig_d_l, self.d_l, kernel_size=1, padding=0, bias=False)
        self.proj_v = nn.Conv1d(self.orig_d_v, self.d_v, kernel_size=1, padding=0, bias=False)

        # 2. 跨模态注意力模块
        self.trans_l_with_v = self.get_network('lv')
        self.trans_v_with_l = self.get_network('vl')

        # 3. 各自模态的 self-attention 模块
        self.trans_l_mem = self.get_network('l_mem', layers=3)
        self.trans_v_mem = self.get_network('v_mem', layers=3)

        # 4. 输出层
        self.proj1 = nn.Linear(combined_dim, combined_dim)
        self.proj2 = nn.Linear(combined_dim, combined_dim)
        self.out_layer = nn.Linear(combined_dim, output_dim)

    def get_network(self, self_type='l', layers=-1):
        if self_type in ['l', 'vl']:
            embed_dim, attn_dropout = self.d_l, self.attn_dropout
        elif self_type in ['v', 'lv']:
            embed_dim, attn_dropout = self.d_v, self.attn_dropout
        elif self_type == 'l_mem':
            embed_dim, attn_dropout = 2 * self.d_l, self.attn_dropout
        elif self_type == 'v_mem':
            embed_dim, attn_dropout = 2 * self.d_v, self.attn_dropout
        else:
            raise ValueError("Unknown network type")

        return TransformerEncoder(embed_dim=embed_dim,
                                  num_heads=self.num_heads,
                                  layers=max(self.layers, layers),
                                  attn_dropout=attn_dropout,
                                  relu_dropout=self.relu_dropout,
                                  res_dropout=self.res_dropout,
                                  embed_dropout=self.embed_dropout,
                                  attn_mask=self.attn_mask)

    def forward(self, x_l, x_a, x_v):
        # 输入：[B, seq_len, embed_dim]
        x_l = F.dropout(x_l.transpose(1, 2), p=self.embed_dropout, training=self.training)
        x_v = x_v.transpose(1, 2)

        proj_x_l = self.proj_l(x_l).permute(2, 0, 1)  # [seq_len, B, d_l]
        proj_x_v = self.proj_v(x_v).permute(2, 0, 1)  # [seq_len, B, d_v]

        h_l_with_vs = self.trans_l_with_v(proj_x_l, proj_x_v, proj_x_v)
        h_v_with_ls = self.trans_v_with_l(proj_x_v, proj_x_l, proj_x_l)

        h_ls = self.trans_l_mem(torch.cat([proj_x_l, h_l_with_vs], dim=2))
        h_vs = self.trans_v_mem(torch.cat([proj_x_v, h_v_with_ls], dim=2))

        if isinstance(h_ls, tuple): h_ls = h_ls[0]
        if isinstance(h_vs, tuple): h_vs = h_vs[0]

        last_h_l = h_ls[-1]  # [B, d_l*2]
        last_h_v = h_vs[-1]  # [B, d_v*2]
        last_hs = torch.cat([last_h_l, last_h_v], dim=1)

        last_hs_proj = self.proj2(F.dropout(F.relu(self.proj1(last_hs)), p=self.out_dropout, training=self.training))
        last_hs_proj += last_hs
        output = self.out_layer(last_hs_proj)
        return output, last_hs
